<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js-惰性函数</title>
    <link href="/2021/05/18/js-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/18/js-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="关于惰性函数"><a href="#关于惰性函数" class="headerlink" title="关于惰性函数"></a>关于惰性函数</h2><pre><code>如字面意思，惰性函数是真的惰吗？我觉得不是，我觉得与其说它是惰，还不如说它是聪明的，它不会去重复地去做某一样东西，而形成冗余。而这也恰好是它的作用，好处！！！而惰性函数的优点：就是能避免多次重复的步骤判断，冗余等，只需一次判定，即可直接去使用，不用做无用的重复步骤惰性函数的应用场景：常用于函数库的编写，单例模式之中。在固定的应用环境不会发生改变，频繁要使用同一判断逻辑的</code></pre><h2 id="惰性函数的例子"><a href="#惰性函数的例子" class="headerlink" title="惰性函数的例子"></a>惰性函数的例子</h2><pre><code>以浏览器的监听事件方法为例：addEventlistener的这种方法是不支持IE浏览器的而IE浏览器是使用attachEvent这个方法当我们想要做到兼容性的时候，肯定要先判断这个浏览器是否适用此方法正常的写法：</code></pre><p><img src="/2021/05/18/js-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/1.PNG"></p><pre><code>我们经常会用这种写法来写，但其实我们每次都要进行判断，重复着之前重复的东西，就导致性能不太好了而我们使用惰性函数这个思想来写的话，就会避免这种重复判断，即一次判断，多次直接使用惰性函数思想的写法：</code></pre><p><img src="/2021/05/18/js-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/2.PNG"></p><pre><code>这样写的话，就相当于第一次判断了，就告诉它，接下来就是这个了，不用再去判断了，直接就用这个方法就好了</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>advance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于一些基础JS</title>
    <link href="/2021/05/03/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80JS/"/>
    <url>/2021/05/03/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80JS/</url>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><pre><code>七种基本数据类型：Boolean，Number，String，Null，Undefined，Symbol，BigInt（比number支持的范围更大的整数值）基本数据类型存放在栈内存中（它们的值互不影响）基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值引用数据类型：Array，Object，Function，Date，RegExp，...引用数据类型是同时保存在栈内存中和堆内存中（引用数据的值存放在堆内存中，引用数据指向堆内存的地址存放在栈内存中）例子：</code></pre><p><img src="/2021/05/03/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80JS/1.PNG" alt="1"><br><img src="/2021/05/03/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80JS/1.1.PNG" alt="1.1"></p><pre><code>怎样区分数组和对象？（三种方法）1. instanceof（返回Boolean值）数组：[] instanceof Array =&gt; true对象：&#123;&#125; instanceof Object =&gt; true2. constructor（只对已定义的变量进行判断）数组：var arr=[]; arr.instanceof =&gt; ƒ Object()对象：var obj=&#123;&#125;; obj.instaceof =&gt; ƒ Array()3. toString()数组：Object.prototype.toString.call([]) =&gt; [object Array]对象：Object.prototype.toString.call(&#123;&#125;) =&gt; [object Object]</code></pre><h2 id="关于this的指向"><a href="#关于this的指向" class="headerlink" title="关于this的指向"></a>关于this的指向</h2><pre><code>改变this的指向：call，apply，bind</code></pre><h2 id="关于原型和原型链"><a href="#关于原型和原型链" class="headerlink" title="关于原型和原型链"></a>关于原型和原型链</h2><p><img src="/2021/05/03/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80JS/2.PNG" alt="2"> </p>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于浏览器</title>
    <link href="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="网页的生成"><a href="#网页的生成" class="headerlink" title="网页的生成"></a>网页的生成</h1><pre><code>可分为5步：1. HTML代码转化成DOM2. CSS代码转化成CSSDOM3. 结合DOM和CSSDOM生成渲染树（包含每个节点的视觉信息）4. 生成布局，将所有渲染树的所有节点进行平面合成5. 将布局绘制在屏幕上前三步都很快，第四，五步耗时（这两步结合在一起合称渲染（生成布局+绘制））</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/1.PNG" alt="1"></p><h1 id="关于重绘和重排（回流）"><a href="#关于重绘和重排（回流）" class="headerlink" title="关于重绘和重排（回流）"></a>关于重绘和重排（回流）</h1><pre><code>当网页需要重新渲染时，就会触发重排和重绘重排：就是重新生成布局重绘：就是重新绘制布局在屏幕重绘不一定需要重排，而重排一定导致重绘重新渲染的情况：1. 修改DOM2. 修改样式表3. 用户事件的触发（如鼠标点击和悬停，页面的滚动和改变大小等）</code></pre><h1 id="有关缓存"><a href="#有关缓存" class="headerlink" title="有关缓存"></a>有关缓存</h1><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><pre><code>有DNS的地方，就会有缓存什么是DNS？什么是DNS解析？DNS：域名系统，它是作为域名和IP地址相互映射的一个分布式数据库（使用UDP端口53）可以这样理解：当你要拜访一个朋友的家，你就要知道这个朋友家的地址，就是通过这个DNS来获得朋友家的地址DNS解析：根据域名得到对应的IP地址的过程  （域名结构：主机名.次级域名.顶级域名.根域名）过程：1. 首先会去搜索浏览器自身的DNS缓存，若存在就直接拿到对应的IP地址2. 若浏览器自身的缓存没有，则会去读取操作系统的host文件看是否存在对应的映射关系，若存在，则拿到对应的IP地址3. 若host文件中不存在对应的映射关系，则查找本地域名服务器（ISP服务器，自己手动设置的DNS服务器），若存在，则拿到对应的IP地址4. 若还是没有，则可以进行以下两种查询   1) 通过迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以DNS客户的身份去各个服务器查询   2) 通过递归查询：本地域名服务器就以DNS客户的身份，向其它根域名服务器发出请求，让根域名服务器替它去查询，而不是让主机自己进行下一步查询    i) 从根域名服务器查到顶级域名服务器的A记录和NS记录（IP地址） （A记录为IP地址，NS记录指向该级域名的域名服务器）    ii) 从顶级域名服务器查到次级域名服务器的A记录和NS记录（IP地址）    iii) 从次级域名服务器查出主机名的IP地址</code></pre><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><pre><code>什么是CDN？CDN为内容分发网络，就相当于一些代售点（CDN节点能起到分流作用,减轻服务器负载压力）关于CDN缓存：在浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求，CDN边缘节点也存在着一套缓存机制：当浏览器向CDN节点请求数据时，这CDN节点会判断缓存数据是否已经过期了，若没过期，则直接将缓存的数据返回给客户端。否则CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，重新更新本地缓存，并会将最新的数据返回给客户端CDN的优点：1. 解决了跨运营商和跨地域访问的问题，访问延时大大降低了2. 大部分请求在CDN边缘节点完成，会起到分流作用，减轻服务器的负载</code></pre><h2 id="关于浏览器的缓存机制"><a href="#关于浏览器的缓存机制" class="headerlink" title="关于浏览器的缓存机制"></a>关于浏览器的缓存机制</h2><pre><code>浏览器缓存：就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为</code></pre><p><strong>浏览器缓存的东西都放在哪里了呢？</strong></p><pre><code>缓存的资源的去向：（webkit的资源分为主资源（如：HTML页面或者一些下载项等）和派生资源（如：HTML页面中内嵌的图片，脚本链接，字体等））1. 内存中（memory cache），下次访问的时候直接从内存中取2. 磁盘中（disk cache），下次访问的时候直接从磁盘中取两者的异同：同：都是只能存储一些派生类资源异：memory cache退出进程时数据会被清除disk cache退出进程时数据不会被清除存储资源：memory cache一般存储脚本（如js（因为随时可能执行）），字体，图片等disk cache一般存储非脚本类（如CSS等（css文件加载一次就可以渲染出来，不会去频繁读取它，所以不适合放在memory cache中））访问缓存的优先级：1. 先在内存中查找，有则直接加载2. 内存没有则在磁盘中查找，有则直接加载3. 磁盘没有，就进行网络请求4. 请求获取到的资源缓存到内存和磁盘中（内存 -&gt; 磁盘 -&gt; 网络请求）</code></pre><p><strong>缓存的分类</strong></p><pre><code>浏览器的缓存可分为两种：强缓存和协商缓存（根据响应的header内容来决定）（优先级：首先判断是否命中强缓存，再判断是否命中协商缓存）强缓存：浏览器在第一次请求的时候，会直接下载资源，然后缓存到本地，到第二次请求时，若资源还没有过期就直接使用缓存      （普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存）       强缓存的header字段信息：Expires，Cache-control，Pragma       若Cache-Control，Expires，Pragma同时设置了，优先级：Pragma &gt; Cache-Control &gt; Expires       1) Expires：是http1.0的规范。其值为一个绝对时间的GMT格式的时间字符串，表示这个资源的失效时间                   第一次请求的时候，告诉客户端该资源会什么时候过期（缺点：必须保证服务器时间和客户端时间严格同步，当服务器与客户端事件偏差较大时，会导致缓存混乱）       2) Cache-Control：是http1.1的规范          取值：max-age | no-cache | no-store | public | private          max-age：这是一个相对时间，表示该资源多少时间后过期，解决了客户端与服务器时间必须同步的问题          no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存          no-store：禁止使用缓存，每一次都要重新请求数据          public：可以被所用的用户缓存，包括终端用户和CDN等中间代理服务器          private：只能被终端用户缓存，包括终端用户和CDN等中间代理服务器       3) Pragma：no-cache（唯一一个属性值）协商缓存：当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，浏览器会发送一个请求到服务器，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性        （简单来说可以认为是客户端与服务器要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问）         协商缓存的header字段信息：Etag/If-None-Match 和 Last-Modified/If-Modified-Since         1) Etag：每一个文件都有，唯一的，相当于文件的hash，可为了解决缓存问题            Etag/If-None-Match的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。            ETag又有强弱校验之分，如果 hash 码是以 &quot;W/&quot; 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。         2) Last-Modified：文件的修改时间，精确到秒            Last-Modified/If-Modified-Since的值代表的是文件的最后修改时间            第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，            再一次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并把它放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。        Last-Modified与ETag可以一起设置，但服务器会优先验证ETag，当一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304        有了Last-Modified，为什么还需要Etag？        1. 一些文件也许会周期性的更改，但它的内容并不改变（仅仅改变了修改时间），这个时候我们并不希望客户端认为这个文件被修改了而去重新请求，所以就利用到了Etag        2. 某些文件修改非常频繁，比如1s修改了n次（即修改的时间粒度是在秒级以下的），而if-Modified-Sience能检查到的时间粒度是秒级的，所以对于这种修改是无法判断的        3. 某些服务器不能精确得到文件的最后修改时间，所以只靠Last-Modified是不行的总的来说：当浏览器再次访问一个已经访问过的资源时，它会有以下做法：1. 先看是否命中强缓存，若命中，就直接使用缓存2. 若没有命中强缓存，就发送请求到服务器检查是否命中协商缓存3. 若命中协商缓存，服务器就会返回304告诉浏览器使用本地缓存4. 若没有命中协商缓存，服务器就会发送200，请求到最新的资源</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/2.png" alt="2"><br><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/3.jpg" alt="3"></p><pre><code>浏览器缓存的优点：1. 减少了冗余的数据传输2. 减少了服务器的负担，大大提升了网站的性能3. 加快了客户端加载网页的速度关于浏览器的刷新问题：1. 当你点击刷新按钮的时候，浏览器会在请求头里加一个&quot;Cache-Control: max-age=0&quot;。因为 max-age 是&quot;生存时间&quot;，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到max-age=0，也就会用一个最新生成的报文回应浏览器2. 而Ctrl+F5的&quot;强制刷新&quot;其实是发了一个&quot;Cache-Control: no-cache&quot;，含义和&quot;max-age=0&quot;基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的</code></pre><h2 id="事件循环机制（Event-Loop）"><a href="#事件循环机制（Event-Loop）" class="headerlink" title="事件循环机制（Event Loop）"></a>事件循环机制（Event Loop）</h2><pre><code>简单来说就是主线程的执行栈都执行完毕后，再去任务队列里看看有哪些事件，任务可以执行了，就把他们放到主线程上执行。然后主线程会重复去操作这一个过程。上面这一个循环的过程，就是所谓的事件循环机制了（再简单来说就是主线程去读取任务队列的事件，而这个读取的过程是循环的）而什么是执行栈？什么是任务队列？对于执行栈，又联系到了一个名词：同步任务而这个同步任务呢，就是在主线程排队等待执行的任务，前一个任务执行完，再执行后一个任务所有的同步任务都会在主线程上执行，这就形成了一个执行栈对于任务队列，又会联系到一个名词：异步任务（异步任务必须指定回调函数）任务队列是用来专门存放异步任务的这个异步任务呢，就是不进入执行栈，而进入任务队列的任务，只有任务队列&quot;通知&quot;主线程某个异步任务可以执行了，则这个异步任务就会被安排进入到主线程中，即进入到执行栈1) 任务队列是怎么通知主线程可以执行对应的异步任务的呢？   任务队列会添加一个对应的事件，表示相关的异步任务可以进入执行栈中了。主线程读取&quot;任务队列&quot;，就是读取里面有哪些事件2) 任务队列中的事件有哪些呢？   除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数(会被主线程挂起来)，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取3) 什么时候会去读取这个任务队列呢？   当主线程空了，执行完毕后就会去读取任务队列中的异步任务4) 任务队列还可以存放定时事件：定时器setInterval和延时器setTimeout   对于这两个定时事件的最小时间间隔，有如下的规定：   setTimeout的最短时间间隔是4毫秒   setInterval的最短间隔时间是10毫秒  （当最短时间间隔小于规定的数值，则会自动增加到这个最小的数值）在异步任务中，我们又分为微任务和宏任务微任务和宏任务又分别存放在微任务队列（只有一个）和宏任务队列（可以有多个）中微任务包括：1) promise（then回调函数的执行需要等promise执行结果决定。promise里面的语句是同步任务，而then是微任务）2) MutaionObserve（构造函数）（注：new Promise()构造函数里面属于同步代码，而非微任务）3) Proxy对象4) process.nextTick(Node.js)宏任务包括：1) script中的代码2) setTimeout/setInterval3) UI rendering4) postMessage：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage5) MessageChannel：https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel6) setImmediate：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate（是用来把一些需要长时间运行的操作放在一个回调函数里,在浏览器完成后面的其他语句后,就立刻执行这个回调函数）7) I/O(Node.js)</code></pre><p>   （主线上的同步任务都执行完了，就先执行微任务再执行宏任务（宏任务中的setTimeout和setInterval要按照时间间隔从小到大开始执行））<br>   （一般来说，宏任务后面都会跟着微任务，宏任务执行完后会查看是否有微任务队列，如果有先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列）<br>   （宏任务会触发新一轮的事件循环，即可能会在下一轮新的事件循环中被执行）<br>   （微任务会放在当前事件循环的末尾）<br>   （执行顺序：先同步加一条异步的微任务，再异步，加上宏任务和微任务）</p><pre><code>Node.js中的Event Loop：在Node.js中，有两个与&quot;任务队列&quot;有关的方法：process.nextTick和setImmediateprocess.nextTick方法在当前&quot;执行栈&quot;的尾部 到 下一次Event Loop（主线程读取&quot;任务队列&quot;）之前去触发回调函数setImmediate方法则是在当前&quot;任务队列&quot;的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像（当发生递归调用的时候，setImmediate指定的回调函数，总是排在setTimeout前面）事件循环的一些关键步骤：1. 在此次事件循环中选择最先进入队列的任务( oldest task )，如果有则执行(一次)2. 检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue3. 更新 render4. 主线程重复执行上述步骤</code></pre><h2 id="关于localStorage-和-sessionStorage"><a href="#关于localStorage-和-sessionStorage" class="headerlink" title="关于localStorage 和 sessionStorage"></a>关于localStorage 和 sessionStorage</h2><pre><code>共同点：1. 都是在客户端存储的2. 都只能存储字符串3. 存储数据的大小大概都是5M（看浏览器）4. 不同的浏览器是无法共享sessionStorage或localStorage的数据5. 建立本地对象和操作数据的方法都一样不同点：1. localStorage存储的数据时永久的   sessionStorage存储的数据时暂时性的，关闭浏览器数据就会消失了。不过另外开一个页面的话数据还是在的2. 相同浏览器不同的页面（相同域名和相同端口）是可以共享相同localStorage中的数据   不同页面或标签页面间是无法共享sessionStorage中的数据（注：当标签页中中包含有同源页面的iframe标签，则是可以共享sessionStorage的数据）</code></pre><h2 id="关于cookie-和-session"><a href="#关于cookie-和-session" class="headerlink" title="关于cookie 和 session"></a>关于cookie 和 session</h2><pre><code>共同点：1. 都是基于键值对的字符串2. 都是后端服务器生成的不同点：1. cookie的数据保存在客户端浏览器中，session的数据保存在服务器端（所以session比cookie安全）2. cookie可以是持久性或会话性的（若不设置过期时间，则关闭浏览器后数据就会消失，会话性的cookie一般保存在内存中（不同浏览器有不同的处理）。若设置了过期时间，则会在过期时间过后数据才会失效，持久性的cookie一般保存在硬盘中（不同的浏览器进程间cookie是可以共享的））   session中的数据是服务器使用一种类似散列表的结构来保存的，也是可以设置超时时间，不过是由服务器来维护的，不同于cookie的失效日期（session一般基于在内存中的cookie）3. 会话性的cookie和session对象的生命周期不一样：关闭浏览器后会话性的cookie已经消失了，session对象还保存在服务器端中，也不会使保存到硬盘上的持久化cookie消失4. cookie保存数据的大小是4k左右（很多浏览器限制一个站点最多只能保存20个cookie，而一个浏览器能创建的Cookie数量最多为 300 个），session保存数据的大小是和服务器内存大小有关联系：1. session中的session_id可以保存在cookie中的，而session_data是保存在服务器   session_id另外的一些保存方法：   1) URL重写：可以利用URL重写来把session_id附加到要请求的URL路径后面（两种附加方式：1. 作为URL路径的附加信息。2. 作为查询字符串附加在URL路径的后面）（使得交互过程中始终保持状态）   2) 表单隐藏字段：服务器会自动修改表单并添加一个隐藏字段，在表单提交时能把session_id传递回服务器   （不过常用的还是用cookie来保存session_id）</code></pre><h2 id="事件的捕获，冒泡，委托"><a href="#事件的捕获，冒泡，委托" class="headerlink" title="事件的捕获，冒泡，委托"></a>事件的捕获，冒泡，委托</h2><pre><code>1. 事件捕获：起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）            从最顶级的父元素一级一级往下找到子元素触发同名事件，直到触发事件的元素为止（从外向内捕获事件对象）            因为事件捕获，只能通过addEventListener并且参数写true才是事件捕获            其他情况都是冒泡（不是通过addEventListener添加、addEventListener参数为false）</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/5.1.PNG" alt="5.1"><br><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/5.PNG" alt="5">  </p><pre><code>    阻止事件捕获：（IE8及之前没有捕获）    事件对象.stopPropagation() ：除了可以阻止冒泡还可以阻止捕获         事件对象.stopImmediatePropagation()：此方法还会阻止元素的其他事件发生   2. 事件冒泡：随即IE也推出了自己的一套事件驱动机制（即事件冒泡）            如果一个元素的事件被触发,那么它所有的父级元素的同名事件都会被触发（从内向外冒泡事件对象）</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/4.1.PNG" alt="4.1"><br><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/4.PNG" alt="4"></p><pre><code>    阻止事件冒泡：（让同名事件不要在父元素中冒泡（触发），即只触发当前点击元素的事件）    事件对象.stopPropagation()      （IE8及之前不支持）    事件对象.cancelBubble = true    （IE8之前支持）    return false    （如果想要阻止事件冒泡，一定要在触发事件的函数中接收事件对象）（最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段）3. 事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件  （当有多个元素要注册事件时，就可以委托到他们的父元素，利用event属性来帮他们注册对应的事件就好了。这个父元素相当于是快递的委托代收点）   事件委托的好处：   1. 优化性能：当给多个元素注册点击事件的时候，只需要委托它的父元素，这样js与dom元素的交互就变为一次，减少了浏览器重绘与重排的次数   2. 减少了内存：给多个元素注册点击事件，每一个元素都会有一个事件函数保存在内存里，多个相同的事件函数与一个事件函数的内存相比，内存节省太多                 同时如果多个元素注册点击事件会造成内存溢出   3. 可以使后来新添加的动态元素绑定事件   事件委托的原理：   比如给li点击事件，事件先开始捕获阶段，从body-&gt;ul-&gt;li   而li是目标元素，此时处于目标阶段，浏览器就会查看是否有点击事件   若发现没有，那么进入冒泡阶段，又从li的父元素ul中发现父元素ul身上有点击事件,那么便触发ul的点击事件</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/6.1.PNG" alt="6.1"><br><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/6.PNG" alt="6">  </p><h2 id="输入URL到页面显示的过程到底是发生了什么？"><a href="#输入URL到页面显示的过程到底是发生了什么？" class="headerlink" title="输入URL到页面显示的过程到底是发生了什么？"></a>输入URL到页面显示的过程到底是发生了什么？</h2><pre><code>大概按照以下几个步骤进行：1. DNS解析2. TCP连接3. 发送HTTP请求4. 服务器处理请求并返回HTTP报文5. 浏览器解析渲染页面6. 连接结束</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><h2 id="window-onload-和-DOMContentLoaded-的区别"><a href="#window-onload-和-DOMContentLoaded-的区别" class="headerlink" title="window.onload 和 DOMContentLoaded 的区别"></a>window.onload 和 DOMContentLoaded 的区别</h2><pre><code>onload事件触发：页面上所有的DOM，样式表，脚本，图片都已经加载完成了DOMContentLoaded事件触发：仅当DOM加载完成，不包括样式表，图片(如果有async加载的脚本就不一定完成)  （IE9以上才兼容）DOMContentLoaded方法的兼容写法：</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/9.PNG" alt="9"></p><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/8.PNG" alt="8"><br><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/8.1.PNG" alt="8.1"><br><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/8.2.PNG" alt="8.2"> </p><pre><code>区分这两个事件可以避免一种情况：绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数（要不然如果某个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的）触发顺序：先触发DOMContentLoaded事件，再触发onload事件</code></pre><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><pre><code>在JavaScript中的内存管理是自动执行的，而且是不可见的。我们创建的基本类型，对象，函数等所有这些都需要内存当不再需要某样东西时会发生什么呢? JavaScript 引擎是如何发现并清理它?垃圾回收机制实则是解决内存泄漏的问题，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存（何为内存泄漏？ 对于那些没有用到的内存，并且没有及时释放，就会造成内存泄漏）各大浏览器通常采用的垃圾回收机制有两种方法：标记清除（常用），引用计数，标记压缩法... (几种垃圾回收的算法https://www.jianshu.com/p/a8a04fd00c3c)1. 标记清除：   垃圾回收机制在运行时，   会先给存储在内存中的所有变量加上对应的标记（可以是任何标记方式），   然后它就会去调出在环境中的变量及被环境中的变量引用的变量标记（闭包），   调出完毕后，剩下带有标记的变量就会被视为准备删除或不再使用的变量（因为环境中的变量已经无法访问这些变量了）   最后垃圾回收机制到下一个周期运行的时候，就会把这些变量的内存释放掉，并回收它们所占用的空间</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/10.1.PNG" alt="10.1"></p><pre><code>   优点：   1) 实现简单，容易和其他算法组合   缺点：   1) 碎片化，会导致无数小分块散落在堆的各处   2) 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块   3) 与写时复制技术不兼容，因为每次都会在活动对象上打上标记2. 引用计数   语言引擎有一张&quot;引用表&quot;，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</code></pre><p><img src="/2021/04/17/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8/10.PNG" alt="10"></p><pre><code>    优点：    1. 可即刻回收垃圾    2. 最大暂停时间短    3. 没有必要沿指针查找，不要和标记-清除算法一样沿着根集合开始查找    缺点：    1. 计数器的增减处理繁重    2. 计数器需要占用很多位    3. 实现繁琐复杂， 每个赋值操作都得替换成引用更新操作    4. 循环引用无法回收......内存泄漏的识别方法：（https://blog.csdn.net/qq_17550381/article/details/81126809）1. 浏览器查看2. 命令行（Node的process.memoryUsage方法）3. WeakMap（ES6）</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于html的一些东西</title>
    <link href="/2021/04/16/%E5%85%B3%E4%BA%8Ehtml%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/"/>
    <url>/2021/04/16/%E5%85%B3%E4%BA%8Ehtml%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="块级元素和行级元素的区别"><a href="#块级元素和行级元素的区别" class="headerlink" title="块级元素和行级元素的区别"></a>块级元素和行级元素的区别</h1><pre><code>块级元素：垂直方向上排列，独占一行，可以包含行内元素和块级元素，设置width，height，line-height，margin，padding有效行级元素：水平方向上排列，都是同一行，不能包含块级元素，设置width，height，margin，padding无效，但设置line-height有效现在行级元素和块级元素能够通过display属性互相转换（现在元素代表的含义与显示无关，元素的包含关系由元素的内容类别决定）</code></pre><h1 id="为什么引入css要用href，而引入js要用src"><a href="#为什么引入css要用href，而引入js要用src" class="headerlink" title="为什么引入css要用href，而引入js要用src"></a>为什么引入css要用href，而引入js要用src</h1><pre><code>src和href的区别：src：本质上是引用嵌入式内容，如img，video，iframe这些替换类型的元素，相当于引入的内容像嵌入页面一样，可以直接展示，直观看到href：本质上是引入超链接，如a，link这些连接型元素。引入的内容是外部资源，与本页面的关系不大，不会直接展示至于为什么要css要用href，js要用src，可能是历史遗留的问题吧引入js的script标签，既可以作为替换型标签，又可以不作为替换型标签引入CSS，可以用style和link标签，而style也不是替换型元素，而我们用link去引入css，就自然是用href啊</code></pre><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="HTML5和HTML4的区别："><a href="#HTML5和HTML4的区别：" class="headerlink" title="HTML5和HTML4的区别："></a>HTML5和HTML4的区别：</h2><pre><code>1. 简化的语法2. canvas替代了flash3. 新增的语义化标签4. 新增的表单控件，媒体元素5. 不再使用frame，center，big，b，font等标签6. 一些本地离线存储和一些新技术7. 一些文件操作的API</code></pre><h2 id="判断浏览器能否使用HTML5"><a href="#判断浏览器能否使用HTML5" class="headerlink" title="判断浏览器能否使用HTML5"></a>判断浏览器能否使用HTML5</h2><pre><code>看window.applicationCache是否存在</code></pre><h2 id="新增的语义化标签"><a href="#新增的语义化标签" class="headerlink" title="新增的语义化标签"></a>新增的语义化标签</h2><pre><code>header，nav，footer，section，article，aside，figure，main语义化的理解：用正确的标签来做正确的事情，语义化标签会让页面的内容结构更加简单易懂，便于搜索引擎解析，便于阅读维护和理解</code></pre><h2 id="新增的表单控件和媒体元素"><a href="#新增的表单控件和媒体元素" class="headerlink" title="新增的表单控件和媒体元素"></a>新增的表单控件和媒体元素</h2><pre><code>表单控件：calander，date，time，email，url，search，...表单属性：required，placeholder，autocomplete，autofocus，一些重写属性（formaction，formenctype，...），list，min，max，multiple，pattern，...媒体元素：video，audio，source，track，embed</code></pre><h2 id="新增的绘图标签"><a href="#新增的绘图标签" class="headerlink" title="新增的绘图标签"></a>新增的绘图标签</h2><pre><code>canvas（主要写JS功能）和SVG</code></pre><h2 id="文件操作的API"><a href="#文件操作的API" class="headerlink" title="文件操作的API"></a>文件操作的API</h2><pre><code>FileList：file文件对象的集合Blob对象：原始数据对象，它提供了slice方法可以读取原始数据中的某块数据File对象：继承自Blob对象，指向一个具体文件FileReader对象：设计用来读取文件里面的数据，提供三个常用的读取文件数据的方法，另外读取文件数据使用了异步的方式，非常高效</code></pre><h2 id="本地存储（WebStorage）"><a href="#本地存储（WebStorage）" class="headerlink" title="本地存储（WebStorage）"></a>本地存储（WebStorage）</h2><pre><code>本地离线存储，把需要离线存储在本地的文件列在一个 manifest 配置文件分为两种：localStorage和sessionStoragelocalStorage和sessionStorage的异同：异：1. localStorage能长期存储数据，关闭浏览器后数据不会丢失   sessionStorage不能长期存储数据（是会话级别的），关闭浏览器后数据会自动删除（刷新页面或进入同源另一页面，数据仍然存在）同：1. 都在客户端中保存，不参与和服务器通信2. 都只能存储字符串3. 存储大小为5M（各浏览器不一样）4. 一些存储，获取，删除数据等的方法相同</code></pre><h2 id="新技术：WebWorker"><a href="#新技术：WebWorker" class="headerlink" title="新技术：WebWorker"></a>新技术：WebWorker</h2><pre><code>WebWorker作用：为JavaScript创建多线程环境，允许主线程创建Worker线程，将一些任务分配给worker线程运行              在主线程运行的同时，Worker线程在后台运行，他们之间互不干扰              等到Worker线程完成计算任务，再把结果通过postMessage返回给主线程好处：对于一些计算密集型或高延迟的任务，被Worker线程负担下来了，主线程就会很流畅，不会被阻塞或被拖慢了由于Worker线程一旦创建成功，就会始终运行，不会被主线程上的活动给打断。这样有利于随时响应主线程的通信不过这也导致Worker线程比较浪费资源，不应该过度使用，使用完毕后应该关闭掉WebWorker的注意点：1. 同源限制：分配给Worker线程运行的脚本文件，必须与主线程运行的脚本文件同源2. DOM限制：Worker线程所在的全局对象与主线程不一样，无法获取到主线程所在网页的DOM结构（Worker无法使用document，window，parent对象，但可以用navigator（包含了浏览器信息），location对象）3. 通信限制：Worker线程和主线程不在同一个上下文环境，他们不能直接通信，必须通过信息完成（此数据通信是拷贝关系，只传值而不传址）  （通信的内部机制：先将通信内容串行化，然后把串行化后的字符串发给Worker，然后Worker再将它还原）4. 脚本限制：Worker线程不能执行alert()和confirm()方法，但可以使用XMLHttpRequest对象发出Ajax请求5. 文件限制：Worker线程无法读取本地文件，他所加载的脚本必须来自网络主线程对worker线程的一些方法：1. 主线程创建Worker线程：在主线程中用new调用Worker的构造函数：var worker=new Worker(&#39;work.js&#39;);  //此脚本文件必须来自网络2. 主线程向Worker发送信息：（可以是各种数据类型）worker.postMessage(&#39;xxxx&#39;) 3. 主线程接收Worker发回来的信息：worker.onmessage=()=&gt;&#123;...&#125;4. 主线程关闭Worker线程：worker.terminate()更多关于WebWorker的用法：http://www.ruanyifeng.com/blog/2018/07/web-worker.html</code></pre><h2 id="新技术：WebSocket"><a href="#新技术：WebSocket" class="headerlink" title="新技术：WebSocket"></a>新技术：WebSocket</h2><pre><code>WebSocket：是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信我们有了HTTP协议了，为什么还要用到WebSocket呢？因为HTTP协议中，通信只能由客户端发起（服务器不能够主动向客户端推送信息）对于若服务器有连续的状态变化，客户端要获取信息就会很麻烦，只能使用轮询去了解有没有新的信息WebSocket的特点：1. 客户端和服务器只需要完成一次握手，它们之间就直接可以创建持久性的连接2. 客户端和服务器双向数据传输（平等对话），能实现真正意义上的推送功能3. 建立在TCP协议之上，服务器的实现比较容易4. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器5. 数据格式比较轻量，性能开销小，通信高效6. 可以发送文本，也可以发送数据7. 没有同源限制，客户端可以和任意的服务器通信8. 协议标识符是ws（若加密则为wss）9. 异步客户端的实现：1. 创建一个socket对象：new WebSocket(url)   //url格式：ws://ip地址:端口号/资源名称2. 一些事件：   1) .onopen：连接建立时触发   2) .onmessage：客户端接收服务器数据时触发   3) .error：通信时发生错误触发   4) .close：连接关闭时触发3. 一些方法：   send()：使用连接发送数据服务器的实现：利用Node搭建服务器与socket配合使用常用Node配合socket.io (服务器与客户端进行配合交互)（socket.io官网：https://socket.io/）更多关于WebSocket的用法：http://www.ruanyifeng.com/blog/2017/05/websocket.html</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于CSS的BFC</title>
    <link href="/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/"/>
    <url>/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/</url>
    
    <content type="html"><![CDATA[<h2 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h2><pre><code>Formatting Context：是页面中的一块渲染区域，并且有一套渲染规则来决定其子元素将如何定位，以及和其他元素的关系和相互作用常见的Formatting Context有：Block Formatting Context（规定了一个区域中常规流块盒的布局）和Inline Formatting Context（规定了一个区域中常规流行盒的布局）</code></pre><h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><pre><code>BFC是Block Formatting Context（块级格式化上下文）它是一块独立的渲染区域，规定了该区域中，常规流块盒的布局</code></pre><h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2><pre><code>1. 其常规流块盒在包含块的垂直方向上依次摆放2. 每个常规流块盒垂直方向的距离是由margin决定的，但属于同一个BFC的两个相邻常规流块盒的margin会发生重叠（margin合并）</code></pre><p><img src="/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/1.gif" alt="1"></p><pre><code>3. 常规流块盒在水平方向上，必须撑满包含块4. BFC的区域不会与浮动的盒子区域重叠</code></pre><p><img src="/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/5.gif" alt="5"></p><pre><code>5. BFC就相当于是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此6. 计算BFC的高度时，浮动元素也会参与计算7. 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此  （即使存在浮动元素，BFC中其他元素的margin box的左边也会与包含块border box的左边相接触）8. 不同的BFC区域，他进行渲染时互不干扰</code></pre><h2 id="BFC的创建"><a href="#BFC的创建" class="headerlink" title="BFC的创建"></a>BFC的创建</h2><pre><code>1. float的属性值不为none（就相当于是浮动的元素）2. position的属性值不为static或relative（就相当于是绝对定位的元素）3. overflow的属性值不为visible4. display的属性值为inline-block，table-cell，flex，table-caption或inline-flex5. html根元素副作用最小的创建方式：overflow：hidden</code></pre><h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><pre><code>1. 利用BFC避免margin的重叠</code></pre><p><img src="/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/2.gif" alt="2"></p><pre><code>2. 自适应两栏布局</code></pre><p><img src="/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/3.gif" alt="3"></p><pre><code>3. 清除浮动</code></pre><p><img src="/2021/04/15/%E5%85%B3%E4%BA%8ECSS%E7%9A%84BFC/4.gif" alt="4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于css隐藏元素（大概8种）</title>
    <link href="/2021/04/15/%E5%85%B3%E4%BA%8Ecss%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0/"/>
    <url>/2021/04/15/%E5%85%B3%E4%BA%8Ecss%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="css隐藏元素的几种方式"><a href="#css隐藏元素的几种方式" class="headerlink" title="css隐藏元素的几种方式"></a>css隐藏元素的几种方式</h2><pre><code>1. display:none2. visibility:hidden3. opacity:04. width,height,margin,padding,border:0 和 overflow:hidden 配合5. position:absolute6. clip-path7. transform:scale(0) 和 zoom 配合8. position:absolute，zoom 和 transform:scale(0) 配合</code></pre><h2 id="display-none（常用）"><a href="#display-none（常用）" class="headerlink" title="display:none（常用）"></a>display:none（常用）</h2><pre><code>元素会彻底消失，元素本身占有的空间就会被其他元素给占有会导致浏览器的重排和重绘不会被子类继承特点：元素不可见，不占据空间，无法响应点击事件</code></pre><h2 id="visibility-hidden（常用）"><a href="#visibility-hidden（常用）" class="headerlink" title="visibility:hidden（常用）"></a>visibility:hidden（常用）</h2><pre><code>仅仅是隐藏元素，DOM还存在（相当于元素还占有空间）不会导致浏览器的重排，但会导致重绘特点：元素不可见，占据页面空间，无法响应点击事件</code></pre><h2 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity:0"></a>opacity:0</h2><pre><code>改变了元素的透明度，相当于隐藏了元素，但它仍会存在在页面中不会导致浏览器的重排，在一般情况下会引发重绘会被子类继承若利用animation动画对opcaity作一个变化（animation会触发GPU加速），这只会触发GPU层面的composite，不会触发重绘它自身是可以触发事件的，但是它被遮挡的子元素则不可以触发事件（而且其子元素不能设置opacity来达到显示的效果）IE8以下的版本：filter:Alpha(opacity=0)特点：改变了元素的透明度显示，元素不可见，占据页面空间，可以响应点击事件</code></pre><h2 id="width-height-margin-padding-border-0与overflow-hidden配合"><a href="#width-height-margin-padding-border-0与overflow-hidden配合" class="headerlink" title="width,height,margin,padding,border:0与overflow:hidden配合"></a>width,height,margin,padding,border:0与overflow:hidden配合</h2><pre><code>把等影响盒模型的属性都设置为0，若其里面还有子元素可设置overflow:hidden来隐藏特点：元素不可见，不占据页面空间，无法响应点击事件</code></pre><h2 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position:absolute"></a>position:absolute</h2><pre><code>利用top，left等属性移出可视区特点：元素不可见，不影响页面的布局</code></pre><h2 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h2><pre><code>clip-path是一种剪裁形式相关用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path特点：元素不可见，占据页面空间，无法响应点击事件</code></pre><h2 id="transform-scale-0-和-zoom-配合"><a href="#transform-scale-0-和-zoom-配合" class="headerlink" title="transform:scale(0) 和 zoom 配合"></a>transform:scale(0) 和 zoom 配合</h2><pre><code>通过利用scale属性来缩放元素大小，zoom设置为0.01进行隐藏注：IE6/IE7/IE9不占据空间，IE8/FireFox/Chrome/Opera占据空间。都无法点击 特点：元素不可见，不占据页面空间，无法响应点击事件</code></pre><h2 id="position-absolute-zoom-transform-scale-0-配合"><a href="#position-absolute-zoom-transform-scale-0-配合" class="headerlink" title="position:absolute, zoom, transform:scale(0) 配合"></a>position:absolute, zoom, transform:scale(0) 配合</h2><pre><code>通过利用scale属性来缩放元素大小，zoom设置为0.01，position:absolute 进行隐藏这样设置相对于上面的方法都不占据空间特点：元素不可见，不占据页面空间，无法响应点击事件</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>隐藏后会占据页面空间：visibility，opacity会触发响应事件：opacity支持与trasition配合使用有渐变效果的：opacity（visibility由于只有0，1两个值，无法有渐变的效果）支持与trasition配合使用的：opacity，visibility子元素可以复原：visibility被遮挡的子元素可以触发事件：visibility（前提是子元素设置了除hidden外的visibility属性）以上的方法也可以根据情况配合使用</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于css的position</title>
    <link href="/2021/04/15/%E5%85%B3%E4%BA%8Ecss%E7%9A%84position/"/>
    <url>/2021/04/15/%E5%85%B3%E4%BA%8Ecss%E7%9A%84position/</url>
    
    <content type="html"><![CDATA[<h2 id="position的取值"><a href="#position的取值" class="headerlink" title="position的取值"></a>position的取值</h2><pre><code>常规的4个值：static（默认值，静态定位）relative（相对定位）absolute（绝对定位）fixed（固定定位）CSS3新增的3个值：centerpagesticky</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><pre><code>可以认为静态的，默认元素都是静态的定位，对象遵循常规流此时4个定位偏移属性不会被应用，也就是使用 left，right，bottom，top 将不会生效</code></pre><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><pre><code>相对定位，对象遵循常规流参照自身在常规流中的位置通过 top，right， bottom，left 这4个定位偏移属性进行偏移时不会影响常规流中的任何元素</code></pre><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><pre><code>绝对定位，对象脱离常规流偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到 body 元素盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠对于离自身最近的定位祖先元素，要满足两个条件：1. 一定是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择 body 为对照对象2. 一定是要求祖先元素必须定位，也就是 position 的属性值为非 static 的都行（常说的套路是：父相子绝）top：没有定位的父辈元素时，参考点是页面左上角。反之参考点则是父父辈元素的左上角bottom：没有定位的父辈元素时，参考点是浏览器首屏的左下角。反之参考点则是父辈元素的左下角。</code></pre><p><img src="/2021/04/15/%E5%85%B3%E4%BA%8Ecss%E7%9A%84position/1.PNG" alt="1"></p><pre><code>绝对定位元素一定是块盒绝对定位元素一定不是浮动      绝对定位的儿子无视padding</code></pre><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><pre><code>固定定位，与 absolute 一致，对象脱离常规流但是固定在浏览器视口，偏移定位是以视口为参考。当出现滚动条时，对象不会随着滚动固定定位元素一定是块盒固定定位元素一定不是浮动   </code></pre><h2 id="center（css3）"><a href="#center（css3）" class="headerlink" title="center（css3）"></a>center（css3）</h2><pre><code>与 absolute 一致，对象脱离常规流偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中</code></pre><h2 id="page（css3）"><a href="#page（css3）" class="headerlink" title="page（css3）"></a>page（css3）</h2><pre><code>与 absolute 一致，元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个 absolute 模式 </code></pre><h2 id="sticky（css3）"><a href="#sticky（css3）" class="headerlink" title="sticky（css3）"></a>sticky（css3）</h2><pre><code>对象在常态时遵循常规流它就像是 relative 和 fixed 的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如 fixed该属性的表现是现实中你见到的吸附效果</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css选择器优先级和样式继承</title>
    <link href="/2021/04/15/css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/04/15/css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%A0%B7%E5%BC%8F%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><pre><code>CSS选择器分别有：1. 元素选择器(span,div,...)2. 类选择器(.xx)3. id选择器(#xx)4. 伪元素选择器(::xx)5. 伪类选择器(:xx)6. 通配符选择器(*)7. 属性选择器([xx])8. 组合选择器(+,~&gt;...)</code></pre><h2 id="关于CSS选择器的优先级"><a href="#关于CSS选择器的优先级" class="headerlink" title="关于CSS选择器的优先级"></a>关于CSS选择器的优先级</h2><pre><code>同类型，同级别的样式，后者优先（覆盖）选择器选中的范围越窄的，优先级越高!important &gt; 内联样式 &gt; id选择器 &gt; 类选择器（/伪类选择器/属性选择器）&gt; 标签选择器（/伪元素选择器）&gt; 通配符选择器 &gt; 继承样式（没有优先级，为0）对于选择器的重叠，可以通过一个四位数来表示其选择器的权重：（规定生效的样式）千位：若有内联样式则加1百位：所有id选择器的数量十位：所有类选择器，属性选择器，伪类选择器的数量个位：所有标签选择器，伪元素选择器的数量通过以上这个四位数，就可以分别判断其权重如果优先级都为0，则遵循就近原则（谁描述的最近，就生效谁的样式），就近原则中都一样近的话，就再比选择器的权重优先级如果权重优先级一样，则样式表中谁写在后面就会覆盖前面的样式注意：!important不能提升继承样式的权重</code></pre><h2 id="关于样式的继承"><a href="#关于样式的继承" class="headerlink" title="关于样式的继承"></a>关于样式的继承</h2><pre><code>只有color，line-xx，font-xx，text-xx等文本样式才会被继承a标签自己有伪类，所以不会继承这些东西</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS盒子模型</title>
    <link href="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><pre><code>盒子模型的示意图：（它包括content，padding，border，margin）</code></pre><p><img src="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/1.PNG" alt="1"></p><pre><code>盒子模型总共有两种：W3C标准盒模型和IE盒模型（怪异盒模型）这两个盒子模型的区别在于它们宽高的计算方式不同常见的块盒：容器元素，h1~h6，p，hr，p，pre，table，ul，ol...常见的行盒：span，a，img，video，b，input，label，strong，i...</code></pre><h2 id="W3C标准盒模型"><a href="#W3C标准盒模型" class="headerlink" title="W3C标准盒模型"></a>W3C标准盒模型</h2><pre><code>标准盒模型计算元素的宽高是只算content的宽高</code></pre><p><img src="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/2.png" alt="2"></p><pre><code>利用css3的box-sizing：content-box可设置标准盒模型（box-sizing的默认值是content-box）</code></pre><h2 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h2><pre><code>IE盒模型又称怪异盒模型怪异盒模型计算元素的宽高是content+padding+border的宽高</code></pre><p><img src="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/3.png" alt="3"></p><pre><code>利用css3的box-sizing：border-box可设置怪异盒模型</code></pre><h2 id="JS获取盒模型的宽高"><a href="#JS获取盒模型的宽高" class="headerlink" title="JS获取盒模型的宽高"></a>JS获取盒模型的宽高</h2><pre><code>设置盒模型元素的宽高有三种方式：内联样式，style标签，通过link标签引入1. 只能获取内联样式设置的宽高dom.style.width/height2. 获取元素渲染后即时的宽高(上面的三种方式都能获取到)，值准确（但只支持IE）dom.currentStyle.width/height3. 获取元素渲染后即时的宽高(上面的三种方式都能获取到)，值准确（兼容性更好）getComputedStyle(dom).width/height4. 获取到元素的宽高(包括content+padding+border)，left和top值（只读）dom.offsetwidth/offsetheight/offsetleft/offsettop5. 获取元素渲染后即时的宽高(上面的三种方式都能获取到)，值准确（兼容性更好），除此之外还能获取到元素的绝对位置（top，bottom，left，right）dom.getBoundingClientRect().width/height/top/left/bottom/right注意IE的一些兼容：在IE7及IE7以下left和top会多出两个像素，IE9以上支持width/height属性获取到的绝对位置都是相当于视口的左上角</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于移动端</title>
    <link href="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <url>/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><pre><code>总共可分为3个视口：布局视口，视觉视口，理想视口布局视口：1. 一般移动设备的浏览器都默认设置一个布局视口，用于解决早起的PC端页面在手机上显示的问题2. 这个视口的分辨率基本都设置为980px</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/4.PNG" alt="4"></p><pre><code>视觉视口：用户所看到的网站区域</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/5.PNG" alt="5"></p><pre><code>理想视口：使得网站在移动端有最理想的浏览和阅读宽度而设定的，是最理想的视口尺寸要手动添加meta视口标签，主要目的：布局视口的宽度应该与理想视口的宽度一致meta标签：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;一些属性值说明：（更多属性说明可到w3c，mdn等官网查询）</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/6.PNG" alt="6"></p><h2 id="一些手机设备的物理像素比-dpr"><a href="#一些手机设备的物理像素比-dpr" class="headerlink" title="一些手机设备的物理像素比(dpr)"></a>一些手机设备的物理像素比(dpr)</h2><pre><code>物理像素比 = 物理像素 / 逻辑像素 物理像素：就是设备所显示的像素（手机截图在ps中量取出来的大小）逻辑像素：页面在css页面中书写的像素由于在手机设备中，会对物理像素放大倍数，就会导致图片模糊所以就要用到倍图</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/7.PNG" alt="7"></p><h2 id="移动端的css样式初始化文件"><a href="#移动端的css样式初始化文件" class="headerlink" title="移动端的css样式初始化文件"></a>移动端的css样式初始化文件</h2><pre><code>normailze.css（下载地址：https://necolas.github.io/normalize.css/）</code></pre><h2 id="单独制作移动端的页面"><a href="#单独制作移动端的页面" class="headerlink" title="单独制作移动端的页面"></a>单独制作移动端的页面</h2><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><pre><code>流式布局是百分比布局设置盒子宽度的百分比来根据屏幕宽度进行缩放，不受固定像素影响，内容向两侧填充要设置盒子的max-width，min-width（保证其缩放在合理范围内）</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/8.PNG" alt="8"></p><h3 id="flex布局（推荐）"><a href="#flex布局（推荐）" class="headerlink" title="flex布局（推荐）"></a>flex布局（推荐）</h3><pre><code>flex能为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局对父容器设置的属性：</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/9.PNG" alt="9"></p><pre><code>对子项设置的属性：</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/11.PNG" alt="11"></p><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/10.PNG" alt="10"></p><h3 id="适配布局（推荐）"><a href="#适配布局（推荐）" class="headerlink" title="适配布局（推荐）"></a>适配布局（推荐）</h3><pre><code>在移动端中的内容按照不同屏幕大小自动等比例缩放的一种布局计算方式能够随着屏幕大小而自适应去变化，元素的高度和宽度等比例缩放rem单位：em单位和rem单位的区别：em是相对父元素的字体大小，rem是相对根元素（html元素）的字体大小优点：可通过修改html里面的文字大小来改变页面中的元素大小，可以实现整体控制媒体查询（CSS3新语法）：使用@media查询，可针对不同的媒体类型定义不同的样式               可针对不同的屏幕尺寸设置不同的样式               重置浏览器大小时，页面会根据浏览器的宽高度重新渲染页面语法：@media mediatype(媒体类型) and/not/only (media feature 媒体特性)&#123;...&#125; mediatype的取值：all(所有设备)，print(打印设备)，screen(电脑屏幕，平板，手机等)关键字：and：可将多个媒体特性连接到一起not 排除某个媒体类型only：指定某个特定的媒体类型媒体特性：1) width：输出设备中页面可见区域的宽度2) min-width：输出设备中页面最小可见区域的宽度3) max-width：输出设备中页面最大可见区域的宽度e.g.@media screen and (max-width:500px)&#123;...&#125;    //在屏幕上页面最大的宽度是500px，在页面宽度为500px内设置的样式才会生效（样式只在屏幕宽度小于等于500像素才生效）@media screen and (min-width:500px) and (max-width:1000px)&#123;...&#125;    //在屏幕上页面宽度为500px到1000px，设置的样式生效媒体查询一般按照从大到小或者从小到大的顺序来去设置（最好是从小到大设置）针对不同的媒体引入对应不同的CSS文件（直接在link判断设备的尺寸，然后引入不同的CSS文件）&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and/only/not (media feature)&quot; href=&quot;xxx&quot;&gt;rem和媒体查询配合使用：利用媒体查询和rem能实现页面的元素动态大小变化e.g.</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/1.PNG" alt="1"></p><pre><code>rem适配方案：按照设计稿与设备宽度的比例，动态计算并设置html根标签的font-size大小CSS中，设计稿元素的宽，高，相对位置等的取值，按照同等比例换算为rem单位的值1. rem + 媒体查询 + less元素大小的rem取值：公式：页面元素的rem值=页面元素的像素值(px) / (屏幕宽度 / 划分的份数)（屏幕宽度 / 划分的份数 就是html的font-size大小，其中划分的份数自定义（一般为10,15））2. flexible.js + rem元素大小的rem取值：页面元素的px值 / (屏幕宽度 / 10)（划分的份数默认划分10等份，根元素的font-size会自动计算出来）可利用vscode的px to rem &amp; rpx (cssrem)插件，px自动转换rem</code></pre><h2 id="响应式页面兼容移动端"><a href="#响应式页面兼容移动端" class="headerlink" title="响应式页面兼容移动端"></a>响应式页面兼容移动端</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><pre><code>根据浏览器宽度，分辨率，横屏，竖屏等情况来自动改变元素展示的一种布局方式一个页面能够兼容多个终端使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的响应式开发设备屏幕尺寸划分：</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/2.PNG" alt="2"></p><pre><code>要有一个响应式布局的容器，显示的子元素按照这个容器的大小而显示相应的大小排列平时的响应式尺寸划分：（设置的宽度比屏幕要小一点是为了中间区域居中，两侧空白，好看一点）</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/3.PNG" alt="3"></p><pre><code>可通过使用bootstrap框架设计响应式布局</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>mobile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css实现水平垂直居中（大概8种）</title>
    <link href="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <url>/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p><strong>对一个东西实现水平垂直居中</strong></p><h2 id="利用text-align和line-height"><a href="#利用text-align和line-height" class="headerlink" title="利用text-align和line-height"></a>利用text-align和line-height</h2><pre><code>针对行级元素</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/1.jpg" alt="1"></p><h2 id="利用table-cell，vertical-align和text-align"><a href="#利用table-cell，vertical-align和text-align" class="headerlink" title="利用table-cell，vertical-align和text-align"></a>利用table-cell，vertical-align和text-align</h2><pre><code>在子元素不确定宽高和数量时，特别实用</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/2.jpg" alt="2"></p><h2 id="利用flex"><a href="#利用flex" class="headerlink" title="利用flex"></a>利用flex</h2><pre><code>简便、完整、响应式</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/3.jpg" alt="3"></p><h2 id="利用grid"><a href="#利用grid" class="headerlink" title="利用grid"></a>利用grid</h2><pre><code>和flex类似有三种实现方式：1. 在父容器中设置display: grid; align-content: center; justify-content: center;2. 在父容器中设置display：grid; 在子元素中设置align-self：center; justify-content：center3. 在父容器中设置display：grid; place-item:center;/place-content:center;</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/4.jpg" alt="4"><br><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/9.PNG" alt="9"></p><h2 id="利用absolute和负margin"><a href="#利用absolute和负margin" class="headerlink" title="利用absolute和负margin"></a>利用absolute和负margin</h2><pre><code>兼容性也很好，不过需要知道子元素的宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/5.jpg" alt="5"></p><h2 id="利用absolute和auto-margin"><a href="#利用absolute和auto-margin" class="headerlink" title="利用absolute和auto margin"></a>利用absolute和auto margin</h2><pre><code>兼容性也很好，不过需要知道子元素的宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/6.jpg" alt="6"></p><h2 id="利用absolute和calc"><a href="#利用absolute和calc" class="headerlink" title="利用absolute和calc"></a>利用absolute和calc</h2><pre><code>此兼容性依赖于calc（不支持IE9以下），且也需要知道宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/7.jpg" alt="7"> </p><h2 id="利用absolute和transform"><a href="#利用absolute和transform" class="headerlink" title="利用absolute和transform"></a>利用absolute和transform</h2><pre><code>此兼容性依赖translate（不支持IE10以下），不需要知道子元素宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/8.jpg" alt="8"> </p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css实现三栏布局</title>
    <link href="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p><strong>假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应</strong></p><p><strong>方案：float布局，absolute布局，表格布局，grid布局，flex布局，双飞翼布局，圣杯布局（共7种）</strong></p><h2 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/1.jpg" alt="1"></p><pre><code>做法：左右两侧部分分别左右浮动，中间容器要设置的左右margin为左右两侧分别的宽度注意：在中间的div区域要放到最前面进行渲染优点：比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等</code></pre><h2 id="absolute布局"><a href="#absolute布局" class="headerlink" title="absolute布局"></a>absolute布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/2.jpg" alt="2"></p><pre><code>做法：对左中右三个区域部分都设置绝对定位，左边区域设置left为0，右边区域设置right为0，中间部分设置的left和right分别是左右区域的宽度优点：很快捷，设置很方便，而且也不容易出问题缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的</code></pre><h2 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/3.jpg" alt="3"></p><pre><code>做法：对包裹的父容器设置display：table，对左中右区域分别设置display：table-cell优点：实现简单，代码少缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的</code></pre><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/4.jpg" alt="4"></p><pre><code>做法：对包裹的父容器设置display：grid，并且设置grid-template-columns：左边宽度 auto（中间宽度自动） 右边宽度，grid-template-rows: 各区域高度注意：在中间的div区域要放到中间进行渲染优点：简单快捷(可以随意组合，其一高度发生变化，另外模块也不会进行跟着变化)缺点：不支持IE10以下</code></pre><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/5.jpg" alt="5"></p><pre><code>做法：对包裹的父容器设置display：flex，设置中间的区域为flex：1注意：在中间的div区域要放到中间进行渲染优点：简单快捷(在不设置高度情况下，min-height除外，那么其一块高度发生变化，其它块高度也会发生变化)缺点：不支持IE10以下</code></pre><h2 id="圣杯布局（通过左浮动加相对定位实现）"><a href="#圣杯布局（通过左浮动加相对定位实现）" class="headerlink" title="圣杯布局（通过左浮动加相对定位实现）"></a>圣杯布局（通过左浮动加相对定位实现）</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/7.png" alt="7"></p><pre><code>做法：对包裹的父容器设置padding（给左右两区域留出位置）。对中间区域设置宽度为100%     对左中右区域设置position：relative和左浮动，左区域的left：-左区域宽度，margin-left：-100%。右区域的right：-右区域宽度，margin-left：-右区域宽度（左右区域占据了父容器的padding部分）注意：最好给body设置一个最小宽度优点：结构简单，无多余dom层缺点：中间部分宽度小于左侧时会发生混乱</code></pre><h2 id="双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）"><a href="#双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）" class="headerlink" title="双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）"></a>双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/6.png" alt="6"></p><pre><code>做法：对左中右区域都设置左浮动，对于中间区域用一个容器包裹着，并设置宽度为100%。中间包裹的子区域，设置左右margin为左右区域的宽度（给左右两区域留出位置）      设置左边区域的margin-left：-100%，设置右边区域的margin-left：-右区域宽度（左右区域所占据的空间是中间区域的margin空间）注意：对于中间的区域一定要有个容器包裹着优点：支持各种宽高变化，通用性强缺点：多了一层包裹中间区域的代码(增加渲染树的计算量)，三栏高度不统一</code></pre><h2 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题"></a>延伸问题</h2><p><strong>若高度不固定，则可以使用哪种布局</strong><br><strong>方案：flex布局，grid布局，table布局</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图</title>
    <link href="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <url>/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="图的表示方式（无向图）"><a href="#图的表示方式（无向图）" class="headerlink" title="图的表示方式（无向图）"></a>图的表示方式（无向图）</h2><pre><code>1. 邻接矩阵（缺点：浪费计算机内存。添加和删除点很麻烦）2. 邻接表</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1.PNG" alt="1"></p><pre><code>一些操作（操作时要先存储vertices顶点，adjList边）1. 添加点</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/4.PNG" alt="4"></p><pre><code>2. 添加边</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/5.PNG" alt="5"></p><h2 id="无向图遍历"><a href="#无向图遍历" class="headerlink" title="无向图遍历"></a>无向图遍历</h2><pre><code>图遍历基本思路：</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/2.PNG" alt="2"></p><pre><code>1. 广度优先遍历（使用队列思想）</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/3.PNG" alt="3"><br><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/7.png" alt="7"></p><pre><code>   广度优先遍历中关于最短路径问题：</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/6.PNG" alt="6"><br><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/9.PNG" alt="9"></p><pre><code>2. 深度优先遍历（使用递归栈思想）</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/8.png" alt="8"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-树</title>
    <link href="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>树结构：</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/1.PNG" alt="1"></p><pre><code>树的每一个节点都包含了：左侧子节点，右侧子节点，自己的值HTML结构就是典型的树结构</code></pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/2.PNG" alt="2"></p><pre><code>一些操作：（操作时要先存储root根结点）1. 插入节点：insert(value)   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/3.png" alt="3"></p><pre><code>2. 移除节点：remove(value) (即重新构建树)   1) 移除没有子节点的节点   2) 移除只有一个子节点的节点（把这一个子节点替代删除的节点）   3) 移除有两个子节点的节点（找到这个删除节点的右子节点的最小值来替代）</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/7.png" alt="7"></p><pre><code>3. 遍历节点：traverse(value)</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/4.PNG" alt="4"></p><pre><code>4. 查找最小节点：min()   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/5.PNG" alt="5"></p><pre><code>5. 查找最大节点：max()   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/6.PNG" alt="6"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-字典</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>一些操作：1. set(key,value)：添加键值对</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/2.PNG" alt="2"></p><pre><code>2. delete(key)：通过键值移除元素</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/3.PNG" alt="3"></p><pre><code>3. has(key)：检查键</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/1.PNG" alt="1"></p><pre><code>4. get(key)：由键获取值</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/4.PNG" alt="4"></p><pre><code>形式：[键:值]对</code></pre><h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><pre><code>散列表：散列表（也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值（通过散列函数转化为对应的哈希值）映射到表中一个位置来访问记录，以加快查找的速度散列表与其他数据结构的比较：其他数据结构获取值时需要遍历，而散列表可以快速定位元素实现简单的哈希表：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/7.png" alt="7"></p><pre><code>散列函数（这里举例两种）：1. loseloseHashCode函数</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/5.PNG" alt="5"></p><pre><code>2. djb2HashCode函数</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/6.PNG" alt="6"></p><pre><code>散列表的冲突问题：若两个散列值相同，哪一个添加早，就会被覆盖掉冲突解决方案：1. 分离链接法：在相同的散列值处，生成一个链表存放相同散列值对应的数据（优势：新创建了一个空间用来存放相同散列值的数据）</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/8.png" alt="8"></p><pre><code>2. 线性探查法：若遇到相同的散列值处有数据时，向下探查空位置，直到有空位置为止（优势：代码比较简单）</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/9.png" alt="9"><br>    3. 也可以利用一些生成的哈希值不那么容易产生冲突的散列函数</p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-集合</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>集合的特性：无重复性</p></li><li><p>一些操作：<br>has(value)：判断是否有value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/1.PNG" alt="1"></p><p>remove(value)：删除value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/2.PNG" alt="2"></p><p>add(value)：添加value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/3.PNG" alt="3"></p><p>clear()：清除集合<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/4.PNG" alt="4"></p><p> size()：获取集合的值的个数<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/5.PNG" alt="5"></p><p>values()：提取集合中的所有值并以数组形式返回<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/6.PNG" alt="6"></p><p> 形式：[值:值]对</p></li></ol><h2 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/7.PNG" alt="7"></p><pre><code>并集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/8.PNG" alt="8"></p><pre><code>交集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/9.PNG" alt="9"></p><pre><code>差集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/10.PNG" alt="10"></p><h2 id="ES6中的集合（Set-WeakSet）"><a href="#ES6中的集合（Set-WeakSet）" class="headerlink" title="ES6中的集合（Set,WeakSet）"></a>ES6中的集合（Set,WeakSet）</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/11.PNG" alt="11"></p><pre><code>Set和WeakSet的区别：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/12.PNG" alt="12"><br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/13.PNG" alt="13"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-链表</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介（单向链表）"><a href="#简介（单向链表）" class="headerlink" title="简介（单向链表）"></a>简介（单向链表）</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/1.PNG" alt="1"></p><pre><code>一些操作：（操作时要先存储head链表头）1. 添加，寻找元素   insert(pos,ele)：指定位置插入元素   1) 向位置0插入元素   2) 向其他位置插入元素</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/2.PNG" alt="2"></p><pre><code>   append(ele)：尾部插入元素   1) 当链表为空时   2) 当链表不为空时</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/3.PNG" alt="3"></p><pre><code>   indexOf(ele)：获取元素的索引</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/5.PNG" alt="5"></p><pre><code>2. 移除元素   remove(ele)：从链表中移除某一项</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/6.PNG" alt="6"></p><pre><code>   removeAt(pos)：从链表指定位置中移除一项   1) 移除首位(第0位)   2) 移除某指定位</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/4.PNG" alt="4"></p><pre><code>3. isEmpty()：判断链表是否为空</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/7.PNG" alt="7"></p><pre><code>4. size()：获取链表的长度</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/8.PNG" alt="8"></p><pre><code>可以把链表类比为火车（不仅有乘客，还与下一节火车相连）</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/9.PNG" alt="9"></p><h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/10.PNG" alt="10"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-队列</title>
    <link href="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>队列是一种先进先出（FIFO）的数据结构一些操作：enqueue()：入列         dequeue()：出列         front()：查看列头         isEmpty()：是否为空         size()：队列长度</code></pre><h2 id="队列和数组"><a href="#队列和数组" class="headerlink" title="队列和数组"></a>队列和数组</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/1.png" alt="1"></p><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/2.PNG" alt="2"></p><h2 id="循环队列实现击鼓传花游戏"><a href="#循环队列实现击鼓传花游戏" class="headerlink" title="循环队列实现击鼓传花游戏"></a>循环队列实现击鼓传花游戏</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/3.PNG" alt="3"></p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><pre><code>优先队列中每个属性都会携带一个优先级 (可用对象表示)优先级高的在队列前面</code></pre><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/4.png" alt="4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构---栈</title>
    <link href="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>栈是一种后进先出（LIFO）的数据结构栈是一种操作受限的线性表，只允许在栈的一端进行数据的插入和删除一些概念：栈底，栈顶，入栈，出栈一些操作：push()：入栈                          pop()：出栈         isEmpty()：是否为空         clear()：清空栈         size()：栈元素个数         peek()：查看栈顶         栈的作用：在编程语言的编译器和内存中保存变量，方法调用可以把栈类比为羽毛球筒装羽毛球</code></pre><h2 id="栈和数组—数组实现相关栈的方法"><a href="#栈和数组—数组实现相关栈的方法" class="headerlink" title="栈和数组—数组实现相关栈的方法"></a>栈和数组—数组实现相关栈的方法</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/4.PNG" alt="4"></p><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/2.png" alt="2"></p><h2 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/1.PNG" alt="1"></p><h2 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a>栈和递归</h2><pre><code>若不停去递归而不出栈的话，就会导致栈溢出</code></pre><h2 id="栈实例：十进制转二进制"><a href="#栈实例：十进制转二进制" class="headerlink" title="栈实例：十进制转二进制"></a>栈实例：十进制转二进制</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/3.PNG" alt="3"></p><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
