<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSS盒子模型</title>
    <link href="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><pre><code>盒子模型的示意图：（它包括content，padding，border，margin）</code></pre><p><img src="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/1.PNG"></p><pre><code>盒子模型总共有两种：W3C标准盒模型和IE盒模型（怪异盒模型）这两个盒子模型的区别在于它们宽高的计算方式不同</code></pre><h2 id="W3C标准盒模型"><a href="#W3C标准盒模型" class="headerlink" title="W3C标准盒模型"></a>W3C标准盒模型</h2><pre><code>标准盒模型计算元素的宽高是只算content的宽高</code></pre><p><img src="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/2.PNG" alt="2"></p><pre><code>利用css3的box-sizing：content-box可设置标准盒模型（box-sizing的默认值是content-box）</code></pre><h2 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h2><pre><code>IE盒模型又称怪异盒模型怪异盒模型计算元素的宽高是content+padding+border的宽高</code></pre><p><img src="/2021/04/15/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/3.PNG" alt="3"></p><pre><code>利用css3的box-sizing：border-box可设置怪异盒模型</code></pre><h2 id="JS获取盒模型的宽高"><a href="#JS获取盒模型的宽高" class="headerlink" title="JS获取盒模型的宽高"></a>JS获取盒模型的宽高</h2><pre><code>设置盒模型元素的宽高有三种方式：内联样式，style标签，通过link标签引入1. 只能获取内联样式设置的宽高dom.style.width/height2. 获取元素渲染后即时的宽高(上面的三种方式都能获取到)，值准确（但只支持IE）dom.currentStyle.width/height3. 获取元素渲染后即时的宽高(上面的三种方式都能获取到)，值准确（兼容性更好）getComputedStyle(dom).width/height4. 获取元素渲染后即时的宽高(上面的三种方式都能获取到)，值准确（兼容性更好），除此之外还能获取到元素的绝对位置（top，bottom，left，right）dom.getBoundingClientRect().width/height/top/left/bottom/right注意IE的一些兼容：在IE7及IE7以下left和top会多出两个像素，IE9以上支持width/height属性获取到的绝对位置都是相当于视口的左上角</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于移动端</title>
    <link href="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <url>/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><pre><code>总共可分为3个视口：布局视口，视觉视口，理想视口布局视口：1. 一般移动设备的浏览器都默认设置一个布局视口，用于解决早起的PC端页面在手机上显示的问题2. 这个视口的分辨率基本都设置为980px</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/4.PNG" alt="4"></p><pre><code>视觉视口：用户所看到的网站区域</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/5.PNG" alt="5"></p><pre><code>理想视口：使得网站在移动端有最理想的浏览和阅读宽度而设定的，是最理想的视口尺寸要手动添加meta视口标签，主要目的：布局视口的宽度应该与理想视口的宽度一致meta标签：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;一些属性值说明：（更多属性说明可到w3c，mdn等官网查询）</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/6.PNG" alt="6"></p><h2 id="一些手机设备的物理像素比-dpr"><a href="#一些手机设备的物理像素比-dpr" class="headerlink" title="一些手机设备的物理像素比(dpr)"></a>一些手机设备的物理像素比(dpr)</h2><pre><code>物理像素比 = 物理像素 / 逻辑像素 物理像素：就是设备所显示的像素（手机截图在ps中量取出来的大小）逻辑像素：页面在css页面中书写的像素由于在手机设备中，会对物理像素放大倍数，就会导致图片模糊所以就要用到倍图</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/7.PNG" alt="7"></p><h2 id="移动端的css样式初始化文件"><a href="#移动端的css样式初始化文件" class="headerlink" title="移动端的css样式初始化文件"></a>移动端的css样式初始化文件</h2><pre><code>normailze.css（下载地址：https://necolas.github.io/normalize.css/）</code></pre><h2 id="单独制作移动端的页面"><a href="#单独制作移动端的页面" class="headerlink" title="单独制作移动端的页面"></a>单独制作移动端的页面</h2><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><pre><code>流式布局是百分比布局设置盒子宽度的百分比来根据屏幕宽度进行缩放，不受固定像素影响，内容向两侧填充要设置盒子的max-width，min-width（保证其缩放在合理范围内）</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/8.PNG" alt="8"></p><h3 id="flex布局（推荐）"><a href="#flex布局（推荐）" class="headerlink" title="flex布局（推荐）"></a>flex布局（推荐）</h3><pre><code>flex能为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局对父容器设置的属性：</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/9.PNG" alt="9"></p><pre><code>对子项设置的属性：</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/11.PNG" alt="11"></p><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/10.PNG" alt="10"></p><h3 id="适配布局（推荐）"><a href="#适配布局（推荐）" class="headerlink" title="适配布局（推荐）"></a>适配布局（推荐）</h3><pre><code>在移动端中的内容按照不同屏幕大小自动等比例缩放的一种布局计算方式能够随着屏幕大小而自适应去变化，元素的高度和宽度等比例缩放rem单位：em单位和rem单位的区别：em是相对父元素的字体大小，rem是相对根元素（html元素）的字体大小优点：可通过修改html里面的文字大小来改变页面中的元素大小，可以实现整体控制媒体查询（CSS3新语法）：使用@media查询，可针对不同的媒体类型定义不同的样式               可针对不同的屏幕尺寸设置不同的样式               重置浏览器大小时，页面会根据浏览器的宽高度重新渲染页面语法：@media mediatype(媒体类型) and/not/only (media feature 媒体特性)&#123;...&#125; mediatype的取值：all(所有设备)，print(打印设备)，screen(电脑屏幕，平板，手机等)关键字：and：可将多个媒体特性连接到一起not 排除某个媒体类型only：指定某个特定的媒体类型媒体特性：1) width：输出设备中页面可见区域的宽度2) min-width：输出设备中页面最小可见区域的宽度3) max-width：输出设备中页面最大可见区域的宽度e.g.@media screen and (max-width:500px)&#123;...&#125;    //在屏幕上页面最大的宽度是500px，在页面宽度为500px内设置的样式才会生效（样式只在屏幕宽度小于等于500像素才生效）@media screen and (min-width:500px) and (max-width:1000px)&#123;...&#125;    //在屏幕上页面宽度为500px到1000px，设置的样式生效媒体查询一般按照从大到小或者从小到大的顺序来去设置（最好是从小到大设置）针对不同的媒体引入对应不同的CSS文件（直接在link判断设备的尺寸，然后引入不同的CSS文件）&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and/only/not (media feature)&quot; href=&quot;xxx&quot;&gt;rem和媒体查询配合使用：利用媒体查询和rem能实现页面的元素动态大小变化e.g.</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/1.PNG" alt="1"></p><pre><code>rem适配方案：按照设计稿与设备宽度的比例，动态计算并设置html根标签的font-size大小CSS中，设计稿元素的宽，高，相对位置等的取值，按照同等比例换算为rem单位的值1. rem + 媒体查询 + less元素大小的rem取值：公式：页面元素的rem值=页面元素的像素值(px) / (屏幕宽度 / 划分的份数)（屏幕宽度 / 划分的份数 就是html的font-size大小，其中划分的份数自定义（一般为10,15））2. flexible.js + rem元素大小的rem取值：页面元素的px值 / (屏幕宽度 / 10)（划分的份数默认划分10等份，根元素的font-size会自动计算出来）可利用vscode的px to rem &amp; rpx (cssrem)插件，px自动转换rem</code></pre><h2 id="响应式页面兼容移动端"><a href="#响应式页面兼容移动端" class="headerlink" title="响应式页面兼容移动端"></a>响应式页面兼容移动端</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><pre><code>根据浏览器宽度，分辨率，横屏，竖屏等情况来自动改变元素展示的一种布局方式一个页面能够兼容多个终端使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的响应式开发设备屏幕尺寸划分：</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/2.PNG" alt="2"></p><pre><code>要有一个响应式布局的容器，显示的子元素按照这个容器的大小而显示相应的大小排列平时的响应式尺寸划分：（设置的宽度比屏幕要小一点是为了中间区域居中，两侧空白，好看一点）</code></pre><p><img src="/2021/04/14/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF/3.PNG" alt="3"></p><pre><code>可通过使用bootstrap框架设计响应式布局</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>mobile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题-css实现水平垂直居中</title>
    <link href="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <url>/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p><strong>对一个东西实现水平垂直居中</strong></p><h2 id="利用text-align和line-height"><a href="#利用text-align和line-height" class="headerlink" title="利用text-align和line-height"></a>利用text-align和line-height</h2><pre><code>针对行级元素</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/1.jpg" alt="1"></p><h2 id="利用table-cell，vertical-align和text-align"><a href="#利用table-cell，vertical-align和text-align" class="headerlink" title="利用table-cell，vertical-align和text-align"></a>利用table-cell，vertical-align和text-align</h2><pre><code>在子元素不确定宽高和数量时，特别实用</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/2.jpg" alt="2"></p><h2 id="利用flex"><a href="#利用flex" class="headerlink" title="利用flex"></a>利用flex</h2><pre><code>简便、完整、响应式</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/3.jpg" alt="3"></p><h2 id="利用grid"><a href="#利用grid" class="headerlink" title="利用grid"></a>利用grid</h2><pre><code>和flex类似有两种实现方式：1. 在父容器中设置display: grid; align-content: center; justify-content: center;2. 在父容器中设置display：grid; 在子元素中设置align-self：center; justify-content：center</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/4.jpg" alt="4"></p><h2 id="利用absolute和负margin"><a href="#利用absolute和负margin" class="headerlink" title="利用absolute和负margin"></a>利用absolute和负margin</h2><pre><code>兼容性也很好，不过需要知道子元素的宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/5.jpg" alt="5"></p><h2 id="利用absolute和auto-margin"><a href="#利用absolute和auto-margin" class="headerlink" title="利用absolute和auto margin"></a>利用absolute和auto margin</h2><pre><code>兼容性也很好，不过需要知道子元素的宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/6.jpg" alt="6"></p><h2 id="利用absolute和calc"><a href="#利用absolute和calc" class="headerlink" title="利用absolute和calc"></a>利用absolute和calc</h2><pre><code>此兼容性依赖于calc（不支持IE9以下），且也需要知道宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/7.jpg" alt="7"> </p><h2 id="利用absolute和transform"><a href="#利用absolute和transform" class="headerlink" title="利用absolute和transform"></a>利用absolute和transform</h2><pre><code>此兼容性依赖translate（不支持IE10以下），不需要知道子元素宽高</code></pre><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/8.jpg" alt="8"> </p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题-css实现三栏布局</title>
    <link href="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p><strong>假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应</strong></p><p><strong>方案：float布局，absolute布局，表格布局，grid布局，flex布局，双飞翼布局，圣杯布局（共7种）</strong></p><h2 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/1.PNG" alt="1"></p><pre><code>做法：左右两侧部分分别左右浮动，中间容器要设置的左右margin为左右两侧分别的宽度注意：在中间的div区域要放到最前面进行渲染优点：比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等</code></pre><h2 id="absolute布局"><a href="#absolute布局" class="headerlink" title="absolute布局"></a>absolute布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/2.png" alt="2"></p><pre><code>做法：对左中右三个区域部分都设置绝对定位，左边区域设置left为0，右边区域设置right为0，中间部分设置的left和right分别是左右区域的宽度优点：很快捷，设置很方便，而且也不容易出问题缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的</code></pre><h2 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/3.PNG" alt="3"></p><pre><code>做法：对包裹的父容器设置display：table，对左中右区域分别设置display：table-cell优点：实现简单，代码少缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的</code></pre><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/4.PNG" alt="4"></p><pre><code>做法：对包裹的父容器设置display：grid，并且设置grid-template-columns：左边宽度 auto（中间宽度自动） 右边宽度，grid-template-rows: 各区域高度注意：在中间的div区域要放到中间进行渲染优点：简单快捷(可以随意组合，其一高度发生变化，另外模块也不会进行跟着变化)缺点：不支持IE10以下</code></pre><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/5.PNG" alt="5"></p><pre><code>做法：对包裹的父容器设置display：flex，设置中间的区域为flex：1注意：在中间的div区域要放到中间进行渲染优点：简单快捷(在不设置高度情况下，min-height除外，那么其一块高度发生变化，其它块高度也会发生变化)缺点：不支持IE10以下</code></pre><h2 id="圣杯布局（通过左浮动加相对定位实现）"><a href="#圣杯布局（通过左浮动加相对定位实现）" class="headerlink" title="圣杯布局（通过左浮动加相对定位实现）"></a>圣杯布局（通过左浮动加相对定位实现）</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/7.png" alt="7"></p><pre><code>做法：对包裹的父容器设置padding（给左右两区域留出位置）。对中间区域设置宽度为100%     对左中右区域设置position：relative，左区域的left：-左区域宽度，margin-left：-100%。右区域的right：-右区域宽度，margin-left：-右区域宽度（左右区域占据了父容器的padding部分）注意：最好给body设置一个最小宽度优点：结构简单，无多余dom层缺点：中间部分宽度小于左侧时会发生混乱</code></pre><h2 id="双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）"><a href="#双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）" class="headerlink" title="双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）"></a>双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/6.png" alt="6"></p><pre><code>做法：对左中右区域都设置左浮动，对于中间区域用一个容器包裹着，并设置宽度为100%。中间包裹的子区域，设置左右margin为左右区域的宽度（给左右两区域留出位置）      设置左边区域的margin-left：-100%，设置右边区域的margin-left：-右区域宽度（左右区域所占据的空间是中间区域的margin空间）注意：对于中间的区域一定要有个容器包裹着优点：支持各种宽高变化，通用性强缺点：多了一层包裹中间区域的代码(增加渲染树的计算量)，三栏高度不统一</code></pre><h2 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题"></a>延伸问题</h2><p><strong>若高度不固定，则可以使用哪种布局</strong><br><strong>方案：flex布局，grid布局，table布局</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图</title>
    <link href="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <url>/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="图的表示方式（无向图）"><a href="#图的表示方式（无向图）" class="headerlink" title="图的表示方式（无向图）"></a>图的表示方式（无向图）</h2><pre><code>1. 邻接矩阵（缺点：浪费计算机内存。添加和删除点很麻烦）2. 邻接表</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1.PNG" alt="1"></p><pre><code>一些操作（操作时要先存储vertices顶点，adjList边）1. 添加点</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/4.PNG" alt="4"></p><pre><code>2. 添加边</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/5.PNG" alt="5"></p><h2 id="无向图遍历"><a href="#无向图遍历" class="headerlink" title="无向图遍历"></a>无向图遍历</h2><pre><code>图遍历基本思路：</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/2.PNG" alt="2"></p><pre><code>1. 广度优先遍历（使用队列思想）</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/3.PNG" alt="3"><br><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/7.png" alt="7"></p><pre><code>   广度优先遍历中关于最短路径问题：</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/6.PNG" alt="6"><br><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/9.PNG" alt="9"></p><pre><code>2. 深度优先遍历（使用递归栈思想）</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/8.png" alt="8"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-树</title>
    <link href="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>树结构：</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/1.PNG" alt="1"></p><pre><code>树的每一个节点都包含了：左侧子节点，右侧子节点，自己的值HTML结构就是典型的树结构</code></pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/2.PNG" alt="2"></p><pre><code>一些操作：（操作时要先存储root根结点）1. 插入节点：insert(value)   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/3.png" alt="3"></p><pre><code>2. 移除节点：remove(value) (即重新构建树)   1) 移除没有子节点的节点   2) 移除只有一个子节点的节点（把这一个子节点替代删除的节点）   3) 移除有两个子节点的节点（找到这个删除节点的右子节点的最小值来替代）</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/7.png" alt="7"></p><pre><code>3. 遍历节点：traverse(value)</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/4.PNG" alt="4"></p><pre><code>4. 查找最小节点：min()   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/5.PNG" alt="5"></p><pre><code>5. 查找最大节点：max()   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/6.PNG" alt="6"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-字典</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>一些操作：1. set(key,value)：添加键值对</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/2.PNG" alt="2"></p><pre><code>2. delete(key)：通过键值移除元素</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/3.PNG" alt="3"></p><pre><code>3. has(key)：检查键</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/1.PNG" alt="1"></p><pre><code>4. get(key)：由键获取值</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/4.PNG" alt="4"></p><pre><code>形式：[键:值]对</code></pre><h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><pre><code>散列表：散列表（也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值（通过散列函数转化为对应的哈希值）映射到表中一个位置来访问记录，以加快查找的速度散列表与其他数据结构的比较：其他数据结构获取值时需要遍历，而散列表可以快速定位元素实现简单的哈希表：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/7.png" alt="7"></p><pre><code>散列函数（这里举例两种）：1. loseloseHashCode函数</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/5.PNG" alt="5"></p><pre><code>2. djb2HashCode函数</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/6.PNG" alt="6"></p><pre><code>散列表的冲突问题：若两个散列值相同，哪一个添加早，就会被覆盖掉冲突解决方案：1. 分离链接法：在相同的散列值处，生成一个链表存放相同散列值对应的数据（优势：新创建了一个空间用来存放相同散列值的数据）</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/8.png" alt="8"></p><pre><code>2. 线性探查法：若遇到相同的散列值处有数据时，向下探查空位置，直到有空位置为止（优势：代码比较简单）</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/9.png" alt="9"><br>    3. 也可以利用一些生成的哈希值不那么容易产生冲突的散列函数</p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-集合</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>集合的特性：无重复性</p></li><li><p>一些操作：<br>has(value)：判断是否有value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/1.PNG" alt="1"></p><p>remove(value)：删除value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/2.PNG" alt="2"></p><p>add(value)：添加value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/3.PNG" alt="3"></p><p>clear()：清除集合<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/4.PNG" alt="4"></p><p> size()：获取集合的值的个数<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/5.PNG" alt="5"></p><p>values()：提取集合中的所有值并以数组形式返回<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/6.PNG" alt="6"></p><p> 形式：[值:值]对</p></li></ol><h2 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/7.PNG" alt="7"></p><pre><code>并集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/8.PNG" alt="8"></p><pre><code>交集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/9.PNG" alt="9"></p><pre><code>差集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/10.PNG" alt="10"></p><h2 id="ES6中的集合（Set-WeakSet）"><a href="#ES6中的集合（Set-WeakSet）" class="headerlink" title="ES6中的集合（Set,WeakSet）"></a>ES6中的集合（Set,WeakSet）</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/11.PNG" alt="11"></p><pre><code>Set和WeakSet的区别：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/12.PNG" alt="12"><br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/13.PNG" alt="13"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-链表</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介（单向链表）"><a href="#简介（单向链表）" class="headerlink" title="简介（单向链表）"></a>简介（单向链表）</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/1.PNG" alt="1"></p><pre><code>一些操作：（操作时要先存储head链表头）1. 添加，寻找元素   insert(pos,ele)：指定位置插入元素   1) 向位置0插入元素   2) 向其他位置插入元素</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/2.PNG" alt="2"></p><pre><code>   append(ele)：尾部插入元素   1) 当链表为空时   2) 当链表不为空时</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/3.PNG" alt="3"></p><pre><code>   indexOf(ele)：获取元素的索引</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/5.PNG" alt="5"></p><pre><code>2. 移除元素   remove(ele)：从链表中移除某一项</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/6.PNG" alt="6"></p><pre><code>   removeAt(pos)：从链表指定位置中移除一项   1) 移除首位(第0位)   2) 移除某指定位</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/4.PNG" alt="4"></p><pre><code>3. isEmpty()：判断链表是否为空</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/7.PNG" alt="7"></p><pre><code>4. size()：获取链表的长度</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/8.PNG" alt="8"></p><pre><code>可以把链表类比为火车（不仅有乘客，还与下一节火车相连）</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/9.PNG" alt="9"></p><h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/10.PNG" alt="10"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-队列</title>
    <link href="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>队列是一种先进先出（FIFO）的数据结构一些操作：enqueue()：入列         dequeue()：出列         front()：查看列头         isEmpty()：是否为空         size()：队列长度</code></pre><h2 id="队列和数组"><a href="#队列和数组" class="headerlink" title="队列和数组"></a>队列和数组</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/1.png" alt="1"></p><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/2.PNG" alt="2"></p><h2 id="循环队列实现击鼓传花游戏"><a href="#循环队列实现击鼓传花游戏" class="headerlink" title="循环队列实现击鼓传花游戏"></a>循环队列实现击鼓传花游戏</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/3.PNG" alt="3"></p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><pre><code>优先队列中每个属性都会携带一个优先级 (可用对象表示)优先级高的在队列前面</code></pre><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/4.png" alt="4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构---栈</title>
    <link href="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>栈是一种后进先出（LIFO）的数据结构栈是一种操作受限的线性表，只允许在栈的一端进行数据的插入和删除一些概念：栈底，栈顶，入栈，出栈一些操作：push()：入栈                          pop()：出栈         isEmpty()：是否为空         clear()：清空栈         size()：栈元素个数         peek()：查看栈顶         栈的作用：在编程语言的编译器和内存中保存变量，方法调用可以把栈类比为羽毛球筒装羽毛球</code></pre><h2 id="栈和数组—数组实现相关栈的方法"><a href="#栈和数组—数组实现相关栈的方法" class="headerlink" title="栈和数组—数组实现相关栈的方法"></a>栈和数组—数组实现相关栈的方法</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/4.PNG" alt="4"></p><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/2.png" alt="2"></p><h2 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/1.PNG" alt="1"></p><h2 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a>栈和递归</h2><pre><code>若不停去递归而不出栈的话，就会导致栈溢出</code></pre><h2 id="栈实例：十进制转二进制"><a href="#栈实例：十进制转二进制" class="headerlink" title="栈实例：十进制转二进制"></a>栈实例：十进制转二进制</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/3.PNG" alt="3"></p><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
