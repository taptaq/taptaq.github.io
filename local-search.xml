<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试题-css实现三栏布局</title>
    <link href="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p><strong>假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应</strong></p><p><strong>方案：float布局，absolute布局，表格布局，grid布局，flex布局，双飞翼布局，圣杯布局（共7种）</strong></p><h2 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/1.PNG" alt="1"></p><pre><code>做法：左右两侧部分分别左右浮动，中间容器要设置的左右margin为左右两侧分别的宽度注意：在中间的div区域要放到最前面进行渲染优点：比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等</code></pre><h2 id="absolute布局"><a href="#absolute布局" class="headerlink" title="absolute布局"></a>absolute布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/2.png" alt="2"></p><pre><code>做法：对左中右三个区域部分都设置绝对定位，左边区域设置left为0，右边区域设置right为0，中间部分设置的left和right分别是左右区域的宽度优点：很快捷，设置很方便，而且也不容易出问题缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的</code></pre><h2 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/3.PNG" alt="3"></p><pre><code>做法：对包裹的父容器设置display：table，对左中右区域分别设置display：table-cell优点：实现简单，代码少缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的</code></pre><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/4.PNG" alt="4"></p><pre><code>做法：对包裹的父容器设置display：grid，并且设置grid-template-columns：左边宽度 auto（中间宽度自动） 右边宽度，grid-template-rows: 各区域高度注意：在中间的div区域要放到中间进行渲染优点：简单快捷(可以随意组合，其一高度发生变化，另外模块也不会进行跟着变化)缺点：不支持IE10以下</code></pre><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/5.PNG" alt="5"></p><pre><code>做法：对包裹的父容器设置display：flex，设置中间的区域为flex：1注意：在中间的div区域要放到中间进行渲染优点：简单快捷(在不设置高度情况下，min-height除外，那么其一块高度发生变化，其它块高度也会发生变化)缺点：不支持IE10以下</code></pre><h2 id="圣杯布局（通过左浮动加相对定位实现）"><a href="#圣杯布局（通过左浮动加相对定位实现）" class="headerlink" title="圣杯布局（通过左浮动加相对定位实现）"></a>圣杯布局（通过左浮动加相对定位实现）</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/7.png" alt="7"></p><pre><code>做法：对包裹的父容器设置padding（给左右两区域留出位置）。对中间区域设置宽度为100%     对左中右区域设置position：relative，左区域的left：-左区域宽度，margin-left：-100%。右区域的right：-右区域宽度，margin-left：-右区域宽度（左右区域占据了父容器的padding部分）注意：最好给body设置一个最小宽度优点：结构简单，无多余dom层缺点：中间部分宽度小于左侧时会发生混乱</code></pre><h2 id="双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）"><a href="#双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）" class="headerlink" title="双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）"></a>双飞翼布局（通过左浮动配合margin实现）（是对圣杯布局的改进）</h2><p><img src="/2021/04/13/%E9%9D%A2%E8%AF%95%E9%A2%98-css%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/6.png" alt="6"></p><pre><code>做法：对左中右区域都设置左浮动，对于中间区域用一个容器包裹着，并设置宽度为100%。中间包裹的子区域，设置左右margin为左右区域的宽度（给左右两区域留出位置）      设置左边区域的margin-left：-100%，设置右边区域的margin-left：-右区域宽度（左右区域所占据的空间是中间区域的margin空间）注意：对于中间的区域一定要有个容器包裹着优点：支持各种宽高变化，通用性强缺点：多了一层包裹中间区域的代码(增加渲染树的计算量)，三栏高度不统一</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图</title>
    <link href="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <url>/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="图的表示方式（无向图）"><a href="#图的表示方式（无向图）" class="headerlink" title="图的表示方式（无向图）"></a>图的表示方式（无向图）</h2><pre><code>1. 邻接矩阵（缺点：浪费计算机内存。添加和删除点很麻烦）2. 邻接表</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/1.PNG" alt="1"></p><pre><code>一些操作（操作时要先存储vertices顶点，adjList边）1. 添加点</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/4.PNG" alt="4"></p><pre><code>2. 添加边</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/5.PNG" alt="5"></p><h2 id="无向图遍历"><a href="#无向图遍历" class="headerlink" title="无向图遍历"></a>无向图遍历</h2><pre><code>图遍历基本思路：</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/2.PNG" alt="2"></p><pre><code>1. 广度优先遍历（使用队列思想）</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/3.PNG" alt="3"><br><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/7.png" alt="7"></p><pre><code>   广度优先遍历中关于最短路径问题：</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/6.PNG" alt="6"><br><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/9.PNG" alt="9"></p><pre><code>2. 深度优先遍历（使用递归栈思想）</code></pre><p><img src="/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/8.png" alt="8"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-树</title>
    <link href="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>树结构：</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/1.PNG" alt="1"></p><pre><code>树的每一个节点都包含了：左侧子节点，右侧子节点，自己的值HTML结构就是典型的树结构</code></pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/2.PNG" alt="2"></p><pre><code>一些操作：（操作时要先存储root根结点）1. 插入节点：insert(value)   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/3.png" alt="3"></p><pre><code>2. 移除节点：remove(value) (即重新构建树)   1) 移除没有子节点的节点   2) 移除只有一个子节点的节点（把这一个子节点替代删除的节点）   3) 移除有两个子节点的节点（找到这个删除节点的右子节点的最小值来替代）</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/7.png" alt="7"></p><pre><code>3. 遍历节点：traverse(value)</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/4.PNG" alt="4"></p><pre><code>4. 查找最小节点：min()   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/5.PNG" alt="5"></p><pre><code>5. 查找最大节点：max()   1) 树为空   2) 树不为空</code></pre><p><img src="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/6.PNG" alt="6"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-字典</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>一些操作：1. set(key,value)：添加键值对</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/2.PNG" alt="2"></p><pre><code>2. delete(key)：通过键值移除元素</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/3.PNG" alt="3"></p><pre><code>3. has(key)：检查键</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/1.PNG" alt="1"></p><pre><code>4. get(key)：由键获取值</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/4.PNG" alt="4"></p><pre><code>形式：[键:值]对</code></pre><h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><pre><code>散列表：散列表（也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值（通过散列函数转化为对应的哈希值）映射到表中一个位置来访问记录，以加快查找的速度散列表与其他数据结构的比较：其他数据结构获取值时需要遍历，而散列表可以快速定位元素实现简单的哈希表：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/7.png" alt="7"></p><pre><code>散列函数（这里举例两种）：1. loseloseHashCode函数</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/5.PNG" alt="5"></p><pre><code>2. djb2HashCode函数</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/6.PNG" alt="6"></p><pre><code>散列表的冲突问题：若两个散列值相同，哪一个添加早，就会被覆盖掉冲突解决方案：1. 分离链接法：在相同的散列值处，生成一个链表存放相同散列值对应的数据（优势：新创建了一个空间用来存放相同散列值的数据）</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/8.png" alt="8"></p><pre><code>2. 线性探查法：若遇到相同的散列值处有数据时，向下探查空位置，直到有空位置为止（优势：代码比较简单）</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/9.png" alt="9"><br>    3. 也可以利用一些生成的哈希值不那么容易产生冲突的散列函数</p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-集合</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>集合的特性：无重复性</p></li><li><p>一些操作：<br>has(value)：判断是否有value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/1.PNG" alt="1"></p><p>remove(value)：删除value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/2.PNG" alt="2"></p><p>add(value)：添加value值<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/3.PNG" alt="3"></p><p>clear()：清除集合<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/4.PNG" alt="4"></p><p> size()：获取集合的值的个数<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/5.PNG" alt="5"></p><p>values()：提取集合中的所有值并以数组形式返回<br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/6.PNG" alt="6"></p><p> 形式：[值:值]对</p></li></ol><h2 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/7.PNG" alt="7"></p><pre><code>并集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/8.PNG" alt="8"></p><pre><code>交集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/9.PNG" alt="9"></p><pre><code>差集：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/10.PNG" alt="10"></p><h2 id="ES6中的集合（Set-WeakSet）"><a href="#ES6中的集合（Set-WeakSet）" class="headerlink" title="ES6中的集合（Set,WeakSet）"></a>ES6中的集合（Set,WeakSet）</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/11.PNG" alt="11"></p><pre><code>Set和WeakSet的区别：</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/12.PNG" alt="12"><br><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9B%86%E5%90%88/13.PNG" alt="13"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-链表</title>
    <link href="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介（单向链表）"><a href="#简介（单向链表）" class="headerlink" title="简介（单向链表）"></a>简介（单向链表）</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/1.PNG" alt="1"></p><pre><code>一些操作：（操作时要先存储head链表头）1. 添加，寻找元素   insert(pos,ele)：指定位置插入元素   1) 向位置0插入元素   2) 向其他位置插入元素</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/2.PNG" alt="2"></p><pre><code>   append(ele)：尾部插入元素   1) 当链表为空时   2) 当链表不为空时</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/3.PNG" alt="3"></p><pre><code>   indexOf(ele)：获取元素的索引</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/5.PNG" alt="5"></p><pre><code>2. 移除元素   remove(ele)：从链表中移除某一项</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/6.PNG" alt="6"></p><pre><code>   removeAt(pos)：从链表指定位置中移除一项   1) 移除首位(第0位)   2) 移除某指定位</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/4.PNG" alt="4"></p><pre><code>3. isEmpty()：判断链表是否为空</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/7.PNG" alt="7"></p><pre><code>4. size()：获取链表的长度</code></pre><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/8.PNG" alt="8"></p><pre><code>可以把链表类比为火车（不仅有乘客，还与下一节火车相连）</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/9.PNG" alt="9"></p><h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p><img src="/2021/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/10.PNG" alt="10"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-队列</title>
    <link href="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>队列是一种先进先出（FIFO）的数据结构一些操作：enqueue()：入列         dequeue()：出列         front()：查看列头         isEmpty()：是否为空         size()：队列长度</code></pre><h2 id="队列和数组"><a href="#队列和数组" class="headerlink" title="队列和数组"></a>队列和数组</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/1.png" alt="1"></p><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/2.PNG" alt="2"></p><h2 id="循环队列实现击鼓传花游戏"><a href="#循环队列实现击鼓传花游戏" class="headerlink" title="循环队列实现击鼓传花游戏"></a>循环队列实现击鼓传花游戏</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/3.PNG" alt="3"></p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><pre><code>优先队列中每个属性都会携带一个优先级 (可用对象表示)优先级高的在队列前面</code></pre><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/4.png" alt="4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构---栈</title>
    <link href="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <url>/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>栈是一种后进先出（LIFO）的数据结构栈是一种操作受限的线性表，只允许在栈的一端进行数据的插入和删除一些概念：栈底，栈顶，入栈，出栈一些操作：push()：入栈                          pop()：出栈         isEmpty()：是否为空         clear()：清空栈         size()：栈元素个数         peek()：查看栈顶         栈的作用：在编程语言的编译器和内存中保存变量，方法调用可以把栈类比为羽毛球筒装羽毛球</code></pre><h2 id="栈和数组—数组实现相关栈的方法"><a href="#栈和数组—数组实现相关栈的方法" class="headerlink" title="栈和数组—数组实现相关栈的方法"></a>栈和数组—数组实现相关栈的方法</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/4.PNG" alt="4"></p><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/2.png" alt="2"></p><h2 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/1.PNG" alt="1"></p><h2 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a>栈和递归</h2><pre><code>若不停去递归而不出栈的话，就会导致栈溢出</code></pre><h2 id="栈实例：十进制转二进制"><a href="#栈实例：十进制转二进制" class="headerlink" title="栈实例：十进制转二进制"></a>栈实例：十进制转二进制</h2><p><img src="/2021/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/3.PNG" alt="3"></p><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先这也是我用hexo搭建这个人博客后发布的第一篇文章吧<br>我之前也发布过18篇文章（分别是在segmentfault，OSCHINA，CSDN平台）<br>在about页中有我各平台的个人主页链接，欢迎关注，不定时更新哦！！！</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><a href="https://nodejs.org/zh-cn/">node</a></li><li>npm（安装完node后就有了），若npm下载速度很慢，可安装cnpm</li><li>node安装hexo-cli模块：npm install -g hexo-cli</li></ol><h2 id="开始搭建（windows平台）"><a href="#开始搭建（windows平台）" class="headerlink" title="开始搭建（windows平台）"></a>开始搭建（windows平台）</h2><ol><li>新建一个文件夹来放置我们的博客</li><li>在这个文件夹中打开cmd，输入相关的命令</li><li>hexo init：初始化创建博客</li><li>hexo s：打开博客（默认地址：<a href="http://localhost:4000）">http://localhost:4000）</a></li><li>hexo n ‘xxxx（文章名）’：新建一篇博客文章</li><li>然后可以在此md文件中编写相关的内容</li><li>hexo g：生成一下文件</li><li>hexo clean：清除缓存（最好每次都清除一下）</li></ol><h2 id="把博客与github关联（推送到github上）"><a href="#把博客与github关联（推送到github上）" class="headerlink" title="把博客与github关联（推送到github上）"></a>把博客与github关联（推送到github上）</h2><p>这个的好处是可以不用去租一台云服务器去挂载，不用申请域名，对学生党很友好</p><ol><li><p>在github上创建一个仓库（注意仓库的命名格式必须为：用户名.github.io）</p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" alt="1"></p></li><li><p>安装hexo-deployer-git：npm install -g hexo-deployer-git</p></li><li><p>编辑一下_config.yml文件</p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png" alt="2"></p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png" alt="3"><br>其中的repo为github仓库的SSH形式的地址（相对于HTTPS的地址，这个地址能减少一些不必要的错误）</p></li><li><p>然后就可以把博客推送到github的仓库中了：hexo d（第一次输入的时候会提示填写github的邮箱，密码，用户名等）</p><p>此时就可以在github仓库中看到所推送的博客文件</p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png" alt="4"></p></li><li><p>这个时候就可以在浏览器中输入刚才命名的仓库名，就可以访问到自己的博客啦</p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.png" alt="5"></p></li></ol><h2 id="修改博客的主题"><a href="#修改博客的主题" class="headerlink" title="修改博客的主题"></a>修改博客的主题</h2><p><a href="https://hexo.io/themes/">hexo主题</a></p><ol><li><p>去clone对应主题中的github仓库：git clone 对应主题仓库的地址 themes/xxx（存放的主题名文件夹）</p></li><li><p>此时在themes文件夹下就可以看到刚才clone的主题文件了</p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/6.png" alt="6"></p></li><li><p>然后编辑_config.yml文件</p><p>theme那一项设置主题的文件夹名就好了</p><p><img src="/2021/04/10/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/7.png" alt="7"><br>然后重新hexo g，hexo d，hexo clean就好了</p></li><li><p>可能博客没那么快有显示变化，可以多刷新几下网址</p></li></ol><p>若遇到图片无法显示的问题，可参考网站：<a href="https://www.jianshu.com/p/ea78bdd0551f/">https://www.jianshu.com/p/ea78bdd0551f/</a></p><p>总的来说，当你修改了你的一些文件后，然后要推送到github远程库中<br>按顺序输入的命令依次为：(大部分情况下)<br>hexo g<br>hexo d<br>hexo clean</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
